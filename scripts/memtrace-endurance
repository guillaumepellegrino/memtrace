#!/bin/sh
#
# Copyright (C) 2022 Guillaume Pellegrino
# This file is part of memtrace <https://github.com/guillaumepellegrino/memtrace>.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.


ME="$0"
RED='\033[0;31m'
GREEN='\033[0;32m'
PRPL='\033[0;35m'
NC='\033[0m'

if [ -e /ext ]; then
    ROOTDIR=/ext
else
    ROOTDIR=/tmp
fi

# Display an error and exit
error()
{
    echo -e "${RED}ERROR{$NC}: $@"
    exit 1
}

# Append files to busybox tar archive
# Busybox does not support the 'append' command
busybox_tar_append()
{
    archive="$1"
    shift
    files="$@"

    bytes=$(wc -c < "$archive")
    blocks=$((bytes / 512))
    seek=$((blocks - 2))
    # echo "Archive Blocks count is $blocks"
    # echo "Append file(s) to block $seek"
    tar -Oc "$files" | dd bs=512 seek=$seek of="$archive" 2> /dev/null
}

# Append files to tar archive
tar_append()
{
    if tar 2>&1 | grep -qi busybox; then
        busybox_tar_append "$@"
    else
        tar -rf "$@"
    fi
}

# Convert string to alpha numeric characters
toalphanum()
{
    tr -c '[a-zA-Z0-9.-]\n' '_'
}

# If running Prpl (openwrt), we may extract system information from
# TR-181 datamodel using CLI.
select_cli()
{
    if type pcb_cli; then
        CLI=pcb_cli
    elif type ba-cli; then
        CLI=ba-cli
    elif type ubus-cli; then
        CLI=ubus-cli
    elif type pcb-cli; then
        CLI=pcb-cli
    else
        CLI=""
    fi
}

# Print the Device Software Version
software_version()
{
    local version=$(
        if [ -n "$VERSION" ]; then
            echo "$VERSION"
        elif [ "$CLI" = "pcb_cli" ]; then
            $CLI -l DeviceInfo.SoftwareVersion?
        elif [ -n "$CLI" ]; then
            $CLI -l Device.DeviceInfo.SoftwareVersion? | grep . | grep -v ERROR
        fi
    )

    (
        if [ -n "$version" ]; then
            printf "$version"
        elif type lsb_release &>/dev/null; then
            lsb_release -sd 2>/dev/null
        else
            uname -r
        fi
    ) | toalphanum
}

# Print the Device Model Name
model_name()
{
    local model=$(
        if [ -n "$MODEL_NAME" ]; then
            echo "$MODEL_NAME"
        elif [ "$CLI" = "pcb_cli" ]; then
            $CLI -l DeviceInfo.ModelName?
        elif [ -n "$CLI" ]; then
            $CLI -l Device.DeviceInfo.ModelName? | grep . | grep -v ERROR
        fi
    )

    (
        if [ -n "$model" ]; then
            printf "$model"
        else
            uname -m
        fi
    ) | toalphanum
}

# Print Kernel Information
kernel()
{
    uname -srvm | toalphanum
}

service_name()
{
    echo $SERVICE | toalphanum
}

# Check if memtrace-endurance is already running
memtrace_endurance_is_running()
{
    if [ -e "$PIDFILE" ]; then
        local pid=$(cat "$PIDFILE")
        if [ -e /proc/$pid ]; then
            error "memtrace-endurance is already running for $SERVICE service with pid $pid"
        fi
    fi
}

# Attach memtrace to specified PID
memtrace_attach()
{
    "$MEMTRACE" -p $PID -x status || error "memtrace failed to attach to $SERVICE with pid $PID"
}

# Create an initial tar archive containing basic debug information
create_tar_archive()
{
    cd "/tmp/"
    rm -rf "$BASENAME/"
    mkdir -p "$BASENAME/"
    select_cli 2> /dev/null
    software_version > "$BASENAME/software_version"
    model_name > "$BASENAME/model_name"
    kernel > "$BASENAME/kernel"
    service_name > "$BASENAME/service"
    for file in /proc/$PID/maps /proc/$PID/status /etc/openwrt_release /web/version.txt; do
        filename=$(basename $file)
        cat "$file" > "$BASENAME/$filename" 2> /dev/null
    done
    tar -cf $ARCHIVE "$BASENAME/" || error "Failed to create $ARCHIVE"
    rm -rf "$BASENAME/"
}

take_coredumps()
{
    echo "Trigger ${CORE_COUNT}x coredump"

    cd /tmp
    local uid_list="$("$MEMTRACE" -p $PID -x "report --count ${CORE_COUNT}" 2>&1 \
        | grep "Memory allocation context .* with UID" \
        | grep -o "UID.*" \
        | cut -d " " -f2)"

    for uid in $uid_list; do
        echo "Taking coredump for memory allocation context with UID $uid"
        mkdir -p "$BASENAME/core"
        local core_gz=$BASENAME/core/memoryctx_uid$uid.core.gz
        "$MEMTRACE" -p $PID -x "coredump --uid $uid --file $core_gz --timeout 120"
        if [ -e $core_gz ]; then
            echo "Adding coredump with uid $uid to $ARCHIVE"
            tar_append $ARCHIVE $core_gz
        fi
        rm -rf "$BASENAME/"
    done
}

take_exit_report()
{
    echo "Killing the application to retrieve exit report"
    cd /tmp
    mkdir -p "$BASENAME/report/"
    "$MEMTRACE" -p $PID -x kill > $BASENAME/report/report_atexit.txt 2>&1
    gzip $BASENAME/report/report_atexit.txt
    tar_append $ARCHIVE $BASENAME/report/report_atexit.txt.gz
    rm -rf $BASENAME/
}

# Backgroung Task running as a daemon
# We periodically take a memory snapshot of the target process
# and append it to the archive.
background()
{
    count=0
    printf "Starting memtrace-endurance background task to monitor $SERVICE with pid $PID @"; date
    showconfig
    echo
    sleep 3
    cd /tmp
    while true; do
        printf "[$count] Generating new report for $SERVICE with pid $PID @"; date
        mkdir -p "$BASENAME/report/"
        if ! "$MEMTRACE" -p $PID -x report > $BASENAME/report/report$count.txt 2>&1; then
            printf "[$count] Endurance test report error: Exiting @"; date
            break
        fi
        grep "in use:\|total heap usage:" $BASENAME/report/report$count.txt
        gzip $BASENAME/report/report$count.txt
        tar_append $ARCHIVE $BASENAME/report/report$count.txt.gz
        rm -rf $BASENAME/

        if [ $count -ge $MAXCOUNT ]; then
            if [ "$CORE_COUNT" -gt 0 ]; then take_coredumps; fi
            if [ "$EXIT_REPORT" = 1 ]; then take_exit_report; fi
            printf "[$count] Endurance test terminated succesfully: Exiting @"; date
            if [ -n "$URL" ]; then upload; fi
            if [ -n "$POST_SCRIPT" ]; then "$POST_SCRIPT"; fi
            rm -f "$PIDFILE"
            break
        fi
        sleep "$INTERVAL"
        count=$((count + 1))
    done
    rm -rf $BASENAME/
    rm -f "$PIDFILE"
    cd -
}

showconfig()
{
    echo -e "Endurance tests configuration:"
    echo -e "  - Output: ${GREEN}$ARCHIVE${NC}"
    echo -e "  - Duration: ${GREEN}$(((INTERVAL*MAXCOUNT)/60)) minutes${NC}"
    echo -e "  - Sampling interval: ${GREEN}${INTERVAL} seconds${NC}"
    echo -e "  - Number of sampling: ${GREEN}${MAXCOUNT}x${NC}"
    echo -e "  - Coredumps: ${GREEN}${CORE_COUNT}x${NC}"
    echo -e "  - Exit Report: ${GREEN}${EXIT_REPORT}${NC}"
    if [ -n "$URL" ]; then
        echo -e "  - Upload URL: ${GREEN}${URL}${NC}"
    else
        echo -e "  - Upload URL: ${GREEN}Not defined${NC}"
    fi
    if [ -n "$POST_SCRIPT" ]; then
        echo -e "  - Post Script: ${GREEN}${POST_SCRIPT}${NC}"
    fi
}

# Start endurance test
start()
{
    memtrace_endurance_is_running
    [ -n "$PID" ] || error "Service $SERVICE is not running"

    echo -e "${GREEN}Attaching memtrace to $SERVICE with pid $PID${NC}"
    memtrace_attach
    echo -e "${GREEN}Memtrace succesfully attached to $SERVICE with pid $PID${NC}"

    echo -e "Creating archive $ARCHIVE"
    create_tar_archive
    echo -e "Archive $ARCHIVE succefully created"
    echo -e "Running memtrace-endurance as a daemon:"
    echo -e "  PIDFILE=$PIDFILE"
    echo -e "  LOGFILE=/tmp/$BASENAME.log"
    start-stop-daemon -S -p $PIDFILE -m -b -x $ME -- $SERVICE background
    echo -e ""
    showconfig

    echo -e "You can retrieve any time you want the endurance results in ${GREEN}$ARCHIVE${NC}"
    echo -e "and view it with memtrace-viewer on your Host simply with:"
    echo -e "memtrace-viewer /path/to/$BASENAME.tar /path/to/rootfs_debug"
    echo -e ""
    echo -e "Check test status with:"
    echo -e "${GREEN}$ME status $SERVICE${NC}"
    echo -e ""
}

# Stop endurance test by killing the background task
stop()
{
    start-stop-daemon -K -p "$PIDFILE"
    rm -f "$PIDFILE"
}

# Show endurance test status
status()
{
    echo -e "$PRPL[Logs from /tmp/$BASENAME.log]$NC"
    cat /tmp/$BASENAME.log
    echo -e "$PRPL[End of logs]$NC"
    echo ""

    if [ -n "$PID" ] && [ -e "/proc/$PID" ]; then
        echo -e "$GREEN[OK]$NC $SERVICE service is running"
    else
        echo -e "$RED[ERROR]$NC $SERVICE service is NOT running"
    fi
    if [ -e "$PIDFILE" ] && [ -e "/proc/$(cat $PIDFILE)" ]; then
        echo -e "$GREEN[OK]$NC Endurance tests are running"
    else
        echo -e "$RED[WARN]$NC Endurance tests are NOT running"
    fi

    echo "Result are available at $ARCHIVE"
}

upload()
{
    if [ -z "$URL" ]; then
        echo -e "$RED[ERROR]$NC URL not specified"
        return 1
    fi
    if ! [ -e "$ARCHIVE" ]; then
        echo -e "$RED[ERROR]$NC $ARCHIVE not found"
        return 1
    fi

    select_cli 2> /dev/null
    local now=$(date "+%y_%m_%d_%Hh%Mm%Ss")
    local product="$(model_name)"
    local version="$(software_version)"
    local service="$(service_name)"

    # Ensure files are sorted by date
    local filename="${now}_${product}_${version}_${service}.tar.gz"

    # Do not include any personal info
    local full_url="$URL?product=${product}&version=${version}&service=${service}&report=${filename}"

    echo "Upload archive to $full_url"
    gzip -c "$ARCHIVE" | curl -v -T - "$full_url"
}

# Display help
usage()
{
    echo "Usage: memtrace-endurance start SERVICE [OPTION]..."
    echo "       memtrace-endurance stop SERVICE"
    echo "       memtrace-endurance status SERVICE"
    echo "       memtrace-endurance help"
    echo ""
    echo "Start/Stop memtrace endurance tests for specified service."
    echo "Let it run for a few hours/days and retrieve the results in $ROOTDIR/memtrace-endurance-SERVICE.tar"
    echo "Use memtrace-viewer to view the results"
    echo ""
    echo "Positional arguments:"
    echo "  start     Start memtrace endurance test"
    echo "  stop      Stop memtrace endurance test background task"
    echo "  status    Show memtrace endurance test status"
    echo "  help      Display this help"
    echo "  SERVICE   Name of the service to attach memtrace (resolved with pidof)"
    echo ""
    echo "Start options:"
    echo "  -p, --pid PID        Service PID"
    echo "  -P, --pidfile FILE   File containing the background task pid"
    echo "  -o, --out TAR_FILE   Path to the output TAR archive containing endurance tests results"
    echo "  -d, --duration TIME  Duration of the endurance test in minutes (default: $DURATION)"
    echo "  -m, --max NUMBER     Max numbers of memory snapshot taken with memtrace (default: $MAXCOUNT)"
    echo "  -b, --bin MEMTRACE   Path to the memtrace binary"
    echo "  -e, --exit-report    Exit the application when test done and take report at exit"
    echo "  -u, --url URL        Upload archive to specified URL when test done"
    echo "  --post-script SCRIPT Run this script POST when test done"
    exit 1
}

# Parse arguments and start the work !
while [ "$#" -gt 0 ]; do
    arg="$1"
    shift
    case "$arg" in
        start) do_start=1;;
        stop) do_stop=1;;
        status) do_status=1;;
        background) do_background=1;;
        upload) do_upload=1;;
        coredump) do_coredump=1; export CORE_COUNT=1;;
        exit) do_exit=1;;
        -h|--help|help) usage;;
        -p|--pid) export PID="$1"; shift;;
        -P|--pidfile) export PIDFILE="$1"; shift;;
        -o|--out) export ARCHIVE="$1"; shift;;
        -i|--interval) export INTERVAL="$1"; shift;;
        -d|--duration) export DURATION="$1"; shift;;
        -m|--max) export MAXCOUNT="$1"; shift;;
        -b|--bin) export MEMTRACE="$1"; shift;;
        -e|--exit-report) export EXIT_REPORT=1;;
        -c|--coredump) export CORE_COUNT="$1"; shift;;
        --post-script) export POST_SCRIPT="$1"; shift;;
        -u|--url) export URL="$1"; shift;;
        -*) echo "Unknown option $arg"; exit 1;;
        *) export SERVICE="$arg";;
    esac
done

if [ -z "$DURATION" ]; then
    export DURATION=180 # 3 hours
fi
if [ -z "$MAXCOUNT" ]; then
    export MAXCOUNT=40 # Max 40x iterations
fi
if [ -z "$INTERVAL" ]; then
    export INTERVAL=$((DURATION * 60 / MAXCOUNT)) # 4.5 minutes
fi
if [ -z "$MEMTRACE" ]; then
    export MEMTRACE=memtrace # memtrace binary path
fi
if [ -z "$CORE_COUNT" ]; then
    export EXIT_REPORT=0
fi
if [ -z "$CORE_COUNT" ]; then
    export CORE_COUNT=0
fi
if [ -z "$SERVICE" ]; then
    usage
fi
if [ -z "$ARCHIVE" ]; then
    export ARCHIVE="$ROOTDIR/memtrace-endurance-$SERVICE.tar"
fi
export BASENAME=$(basename $ARCHIVE .tar)
if [ -z "$PIDFILE" ]; then
    export PIDFILE=/tmp/$BASENAME.pid
fi
if [ -z "$PID" ]; then
    export PID=$(pidof "$SERVICE")
fi

if [ -n "$do_stop" ]; then
    stop
elif [ -n "$do_start" ]; then
    start
elif [ -n "$do_status" ]; then
    status
elif [ -n "$do_upload" ]; then
    upload
elif [ -n "$do_coredump" ]; then
    take_coredumps
elif [ -n "$do_background" ]; then
    background > /tmp/$BASENAME.log 2>&1
else
    usage
fi
